; ------------------------------------------------------------------------------
; Monitor.z80
; ------------------------------------------------------------------------------
; System monitor/debugger
; ------------------------------------------------------------------------------
; Interis 64 Z80 Computer
; https://github.com/Interis64
; 
; Copyright 2023 Matthew Martin
; Licensed under the GNU GPL 3.0. See the LICENSE file for details.
; ------------------------------------------------------------------------------
; Commands
; M addr        - Start interactive memory editor at address 'addr'
; D addr size   - Dump 'size' bytes of raw memory over serial port starting with address 'addr'
; X addr        - Jump to memory address hhll and execute code
; Q             - Quit the monitor (resume if we broke in via NMI, reset otherwise)
; ------------------------------------------------------------------------------
Monitor: PROC
; ------------------------------------------------------------------------------

CommandBufferMax:       EQU 16                                  ; Max of 16 chars for commands
CommandBufferLength:    DS  1                                   ; Memory location for the current size of the command buffer
CommandBuffer:          DS  CommandBufferMax                    ; Memory location for the command buffer (16 bytes)
DataBufferMax:          EQU 23                                  ; Max of 23 chars for data (8 hex bytes with spaces between)
DataBufferLength:       DS  1                                   ; Memory location for the current size of the data buffer
DataStartAddress:       DS  2                                   ; Memory location for the Memory Editor start address
DataBuffer:             DS  DataBufferMax                       ; Memory location for the data buffer (23 bytes)

; If we got here from a non-maskable interrupt, then we'll swap out the registers
; so we don't clobber the running program. When the Monitor exits, we
; swap them back and give control back.
NMIHandler:
    EX      AF, AF'
    EXX

    ; Call instead of jump, so we put this return address on the stack
    CALL    ControlLoop
    
    ; When the user quits the monitor, we'll pick up here
    EXX
    EX      AF, AF'
    RETN

; If we got here from an external call, then we'll swap out the registers
; so we don't clobber the running program. When the Monitor exits, we
; swap them back and give control back.
DebugHandler:
    EX      AF, AF'
    EXX

    ; Call instead of jump, so we put this return address on the stack
    CALL    ControlLoop
    
    ; When the user quits the monitor, we'll pick up here
    EXX
    EX      AF, AF'
    RET

Start:
    LD      HL, $0000                       ; Push $0000 to the stack so we do a cold reset on a quit command
    PUSH    HL

ControlLoop:
    CALL    AcceptInput
    CALL    ProcessInput
    JP      ControlLoop

; -------------------------------------
; Accept Input - Reads up to 16 bytes of ASCII from the user
; -------------------------------------
AcceptInput:
    LD      HL, CommandPrompt               ; Print our prompt
    CALL    Utils.PrintString
    XOR     A                               ; Zero out the length
    LD      (CommandBufferLength), A        
    LD      HL, CommandBuffer               ; Point HL at the command buffer
AcceptInputLoop:
    CALL    BufferedInput.Read

    CP      ASCII.LF                        ; Ignore LF character
    JP      Z, AcceptInputLoop

    CP      ASCII.CR                        ; CR completes input
    RET     Z

    CP      ASCII.BS                        ; Handle Backspace
    JP      Z, AcceptBackspace

    CP      ASCII.ESC
    JP      Z, AcceptInput                  ; Esc key aborts the current line and prompts again

    LD      B, A
    LD      A, (CommandBufferLength)        ; Check if we're at the max input size
    CP      CommandBufferMax
    JP      Z, AcceptInputLoop              ; If we're at max size, do nothing
    LD      A, B
    RST     $08                 ; Echo back to the screen
    LD      (HL), A                         ; Stuff in the command buffer
    INC     HL                              ; Move to the next location
    LD      A, (CommandBufferLength)        ; Increment our length counter
    INC     A
    LD      (CommandBufferLength), A        
    JP      AcceptInputLoop                 ; Wait for the next input

AcceptBackspace:
    LD      A, (CommandBufferLength)        ; Load our length counter
    CP      $00                             ; If we're at zero length, can't backspace
    JP      Z, AcceptInputLoop              ; So just go back to our input loop
    LD      A, ASCII.BS                     ;
    RST     $08                             ; Output the backspace char
    DEC     HL                              ; Go back a spot
    LD      A, (CommandBufferLength)        ; Decrement our length counter
    DEC     A
    LD      (CommandBufferLength), A
    JP      AcceptInputLoop

; -------------------------------------
; Process Input - Decides what to do based on the user's input
; -------------------------------------
ProcessInput:
    ; LD      A, ASCII.LF
    ; RST     $08
    ; RST     $08
    LD      HL, CommandBuffer
    LD      A, (HL)
    CP      'M'
    JP      Z, ProcessMemoryEditorCommand
    CP      'm'
    JP      Z, ProcessMemoryEditorCommand
    CP      'X'
    JP      Z, ProcessExecuteCommand
    CP      'x'
    JP      Z, ProcessExecuteCommand
    CP      'D'
    JP      Z, ProcessDumpCommand
    CP      'd'
    JP      Z, ProcessDumpCommand
    CP      'Q'
    JP      Z, ProcessQuitCommand
    CP      'q'
    JP      Z, ProcessQuitCommand
    ; Unknown, so complain to the user and ask again
CommandError:
    LD      HL, ErrorString
    JP      Utils.PrintString

; -------------------------------------
; Memory Editor Command [M addr]
; -------------------------------------
ProcessMemoryEditorCommand:
    LD      A, (CommandBufferLength)        ; Check command length
    CP      6                               ; 6 bytes
    JP      NZ, CommandError
    LD      HL, CommandBuffer+2
    CALL    ReadHexWord
    EX      DE, HL
    LD      (DataStartAddress), HL

    LD      A, ASCII.LF
    RST     $08
    ; Fall through to ME_ControlLoop (Tail Call)

ME_ControlLoop:
    CALL    ME_PrintMemory
    CALL    ME_AcceptInput
    CALL    ME_ProcessInput
    JP      ME_ControlLoop

; Prints out 8 bytes of memory from the current address pointer as hex
ME_PrintMemory:
    LD      A, ASCII.CR
    RST     $08
    LD      A, '['
    RST     $08
    LD      HL, (DataStartAddress)          ; Get the address pointer
    PUSH    HL                              ; Copy to DE
    POP     DE
    CALL    PrintHexWord                    ; Print address pointer
    LD      A, ']'
    RST     $08

    LD      B, 8
ME_PrintMemoryLoop:
    LD      A, ' '
    RST     $08
    LD      A, (HL)
    CALL    PrintHexByte
    INC     HL
    DJNZ    ME_PrintMemoryLoop
    RET

ME_AcceptInput:
    LD      A, ' '                          ; Clear out the input buffer with blanks
    LD      HL, DataBuffer
    LD      B, DataBufferMax
ME_ClearInputBufferLoop:
    LD      (HL), A
    INC     HL
    DJNZ    ME_ClearInputBufferLoop
    XOR     A                               ; Set the buffer length to zero
    LD      (DataBufferLength), A

    LD      HL, DataPrompt                  ; Print our prompt
    CALL    Utils.PrintString
    LD      HL, DataBuffer                  ; Point HL at the data buffer
ME_AcceptInputLoop:
    CALL    BufferedInput.Read
    CP      ASCII.CR                        ; CR completes input
    RET     Z                               ; So return out of the input loop
    CP      ASCII.LF                        ; Ignore LF character
    JP      Z, ME_AcceptInputLoop
    CP      ASCII.BS                        ; Handle Backspace
    JP      Z, ME_AcceptBackspace
    CP      ASCII.ESC
    JP      Z, ME_AcceptEscape              ; Esc key handler

    LD      B, A                            ; Temporary store of input char
    LD      A, (DataBufferLength)           ; Check if we're at the max input size
    CP      DataBufferMax
    JP      Z, ME_AcceptInputLoop           ; If we're at max size, do nothing
    LD      A, B                            ; Restore input char
    RST     $08                             ; Echo back to the screen
    LD      (HL), A                         ; Stuff into the data buffer
    INC     HL                              ; Move to the next location
    LD      A, (DataBufferLength)           ; Increment our length counter
    INC     A
    LD      (DataBufferLength), A        
    JP      ME_AcceptInputLoop              ; Wait for the next input

ME_AcceptEscape:
    LD      A, (DataBufferLength)           ; Load our length counter
    CP      $00                             ; If we've entered text, clear it and accept input again
    JP      NZ, ME_AcceptInput              
                                            ; But if it's a blank line, we exit the memory editor
    POP     HL                              ; Pop off the extra stack pointer
    RET                                     ; This should return back to the main monitor loop

ME_AcceptBackspace:
    LD      A, (DataBufferLength)           ; Load our length counter
    CP      $00                             ; If we're at zero length, can't backspace
    JP      Z, ME_AcceptInputLoop           ; So just go back to our input loop
    LD      A, ASCII.BS                     ;
    RST     $08                             ; Output the backspace char
    DEC     HL                              ; Go back a spot
    LD      A, (DataBufferLength)           ; Decrement our length counter
    DEC     A
    LD      (DataBufferLength), A
    JP      ME_AcceptInputLoop

; -------------------------------------
; ME Process Input - Parses/writes any new data bytes and increments the address pointer
; -------------------------------------
ME_ProcessInput:
    LD      A, (DataBufferLength)           ; If the user entered nothing, then go to the next memory block
    CP      0
    JP      Z, ME_IncrementAddress
    LD      HL, DataBuffer
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte
    CALL    ME_CheckDataByte

    LD      HL, DataBuffer
    LD      DE, (DataStartAddress)
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte
    CALL    ME_UpdateDataByte

    RET

ME_IncrementAddress:
    LD      HL, (DataStartAddress)
    INC     HL
    INC     HL
    INC     HL
    INC     HL
    INC     HL
    INC     HL
    INC     HL
    INC     HL
    LD      (DataStartAddress), HL
    RET

ME_CheckDataByte:
    LD      A, (HL)
    CP      ' '
    JP      Z, ME_CheckDataByteSkip
    CALL    TestHexDigitSpace
    JP      PO, ME_DataError
    INC     HL
    LD      A, (HL)
    CALL    TestHexDigitSpace
    JP      PO, ME_DataError
    INC     HL
    INC     HL
    RET
ME_CheckDataByteSkip:
    INC     HL
    INC     HL
    INC     HL
    RET

ME_UpdateDataByte:
    LD      A, (HL)                         ; If it's a space, we can skip this byte
    CP      ' '
    JP      Z, ME_UpdateDataByteSkip
    CALL    ReadHexByte
    LD      (DE), A                         ; Store the new value
    INC     DE
    INC     HL                              ; Skip the space after the value
    RET
ME_UpdateDataByteSkip:
    INC     DE
    INC     HL
    INC     HL
    INC     HL
    RET

ME_DataError:
    LD      HL, ErrorString
    CALL    Utils.PrintString
    POP     HL                              ; Pop off an extra stack frame
    RET

; -------------------------------------
; Execute Command [X addr]
; -------------------------------------
ProcessExecuteCommand:
    LD      A, (CommandBufferLength)        ; Check command length
    CP      6                               ; 6 bytes
    JP      NZ, CommandError
    LD      HL, CommandBuffer+2
    CALL    ReadHexWord
    PUSH    DE                              ; Push onto the stack and we'll abuse RET to jump there
    RET                                     ; This is going to jump to the address we just pushed from DE

; Note that we don't really expect to come back from where we jumped,
; but a RET from there will send us back into the monitor loop

; -------------------------------------
; Dump Command [D addr size]
; -------------------------------------
ProcessDumpCommand:
    LD      A, (CommandBufferLength)        ; Check command length
    CP      11                              ; 11 bytes
    JP      NZ, CommandError
    LD      HL, CommandBuffer+1
    LD      A, (HL)
    CP      $20                             ; Next char needs to be ASCII space
    JP      Z, CommandError
    INC     HL
    CALL    ReadHexWord                     ; This is the starting address
    PUSH    DE
    INC     HL                              ; Skip the space
    CALL    ReadHexWord                     ; This is the byte length
    LD      B, D                            ; Copy to our counter
    LD      C, E
    POP     HL                              ; Get the address into HL

DumpLoop:
    LD      A, (HL)
    RST     $08
    INC     HL
    DEC     BC
    LD      A, B
    OR      C
    JP      NZ, DumpLoop


    RET


; -------------------------------------
; Quit command [Q]
; -------------------------------------
ProcessQuitCommand:
    LD      A, (CommandBufferLength)        ; Check command length
    CP      1                               ; 1 byte
    JP      NZ, CommandError
    CALL    Utils.PrintCRLF
    POP     HL                              ; Pop off our monitor return address
    RET                                     ; Return to the previous address (outside of Monitor)

; -------------------------------------
; I/O Out command [O]
; -------------------------------------

; -------------------------------------
; I/O In command [I]
; -------------------------------------

; ------------------------------------------------------------------------------
; Hexadecimal I/O routines
; ------------------------------------------------------------------------------
; Reads a 16-bit hex value from user input into DE
; (HL should point to the start of the four-character string in the input buffer)
ReadHexWord:
    CALL    ReadHexByte
    LD      D, A
    CALL    ReadHexByte
    LD      E, A
    RET

; Reads an 8-bit hex value from user input into A
; (HL should point to the start of the two-character string in the input buffer)
ReadHexByte:
    PUSH    DE
    LD      A, (HL)
    CALL    ReadHexNibble
    ADD     A, A
    ADD     A, A
    ADD     A, A
    ADD     A, A
    LD      D, A
    INC     HL
    LD      A, (HL)
    CALL    ReadHexNibble
    OR      D
    INC     HL
    POP     DE
    RET

ReadHexNibble:
    CP      'a'
    JR      C, ReadHexNibbleUC
    SUB     $20                             ; Convert Lowercase to Uppercase
ReadHexNibbleUC:
    SUB     '0'
    CP      $0A
    RET     C
    SUB     'A'-'0'-10
    RET

; Prints the hex string representing the word value in DE
PrintHexWord:
    LD      A, D
    CALL    PrintHexByte
    LD      A, E
    ; Fall through to PrintHexByte

; Prints the hex string representing the byte value in A
PrintHexByte:
    PUSH    AF
    RRA
    RRA
    RRA
    RRA
    CALL    PrintHexNibble
    POP     AF
    ; Fall through to PrintHexNibble

; Prints the hex character representing the low nibble of A
PrintHexNibble:
    AND     $0F
    ADD     A, $90
    DAA
    ADC     A, $40
    DAA
    RST     $08
    RET

; Tests if A contains a valid hex digit
; Afterwards, you can do this:
; 	jp po,not_found
TestHexDigit:
    PUSH    HL
    LD      HL, HexDigits
    LD      BC, 22                          ; 22 possible characters
    CPIR
    POP     HL
    RET

; Tests if A contains a valid hex digit or a space
; Afterwards, you can do this:
; 	jp po,not_found
TestHexDigitSpace:
    PUSH    HL
    PUSH    BC
    LD      HL, HexDigits
    LD      BC, 23                          ; 23 possible characters
    CPIR
    POP     BC
    POP     HL
    RET

HexDigits:
    DB      "0123456789ABCDEFabcdef "
CommandPrompt:
    DB      ASCII.CR, ASCII.LF, "] ", $00
DataPrompt:
    DB      ASCII.CR, ASCII.LF, "     : ", $00
ErrorString:
    DB      ASCII.CR, ASCII.LF, " ???", $00

    ENDP
