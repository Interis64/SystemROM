; ------------------------------------------------------------------------------
; TMS9918A.z80
; ------------------------------------------------------------------------------
; TMS9918A video card support
; ------------------------------------------------------------------------------
; Interis 64 Z80 Computer
; https://github.com/Interis64
; 
; Copyright 2023 Matthew Martin
; Licensed under the GNU GPL 3.0. See the LICENSE file for details.
; ------------------------------------------------------------------------------
TMS9918A: PROC
; ------------------------------------------------------------------------------
	INCLUDE "TMSFont.z80"

TextScreenEnd:      EQU $17C0               ; VRAM Address one past the last char of the screen
CursorBlinkTime:    EQU 30                  ; Cursor blink time (number of frames)

    SECTION SYSRAM
Installed:          DS VIRTUAL 1            ; Set this to non-zero if the card is intalled and detected
ControlPort:        DS VIRTUAL 1            ; The IO address for the VDP's control port
DataPort:           DS VIRTUAL 1            ; The IO address for the VDP's data port
CursorPosition:     DS VIRTUAL 2            ; The VRAM address of the text cursor
LinePosition:       DS VIRTUAL 1            ; The cursor position relative to the start of the line
CursorChar:         DS VIRTUAL 1            ; The font character to display as the text mode cursor
CursorBlinkEnabled: DS VIRTUAL 1            ; Non-zero if cursor blinking is enabled
CursorCharBuffer:   DS VIRTUAL 1            ; Space to store the character thet's "under" the cursor (for blinking)
CursorBlinkTimer:   DS VIRTUAL 1            ; Counter for making the cursor blink
CursorVisible:      DS VIRTUAL 1            ; Non-zero if the cursor is currently visible
LineCopyBuffer:     DS VIRTUAL 240          ; Space to copy six lines worth of text (for scrolling)
    ENDS

Initialize:
    ; Clear the installed flag (this will be set based on tests later in the init routine)
    LD      A, $00
    LD      (Installed), A

    LD      A, $FF                          ; Set the default cursor character
    LD      (CursorChar), A
    
    LD      A, 1                            ; Enable blinking cursor
    LD      (CursorBlinkEnabled), A

    CALL    LookForCard
    LD      A, (Installed)
    CP      $00                             ; Check if the card is not installed
    RET     Z                               ; Bail out if card is not installed

    DEC     A                               ; Get back to base address
    SLA     A                               ; A << 4 to get IRQ number
    SLA     A
    SLA     A
    SLA     A
    LD      H, $80                          ; Point HL at the interrupt table
    LD      L, A                            ; location for this IRQ number
    LD      (HL), IRQHandler                ; Plop our IRQ routine pointer there

	LD      B, $00                          ; Register 0
	LD      A, 00000000b                    ; Disable Mode3, Disable External VDP
	CALL    WriteRegister
	
	INC     B                               ; Register 1
	LD      A, 11110000b                    ; 4116 RAM, Interupt Enabled, No Blanking, Text Mode
	CALL    WriteRegister

	INC     B                               ; Register 2
	LD      A, $05                          ; Pattern Name Table Base Address 0x1400
	CALL    WriteRegister

	INC     B                               ; Register 3
	LD      A, $80                          ; Color Table Base Address 0x2000
	CALL    WriteRegister

	INC     B                               ; Register 4
	LD      A, $01                          ; Pattern Generator Base Address 0x0800
	CALL    WriteRegister

	INC     B                               ; Register 5
	LD      A, $20                          ; Sprite Attribute Table Base Address 0x1000
	CALL    WriteRegister

	INC     B                               ; Register 6
	LD      A, $00                          ; Sprite Pattern Generator Base Address 0x0000
	CALL    WriteRegister

; TODO: Load color config from NVRAM

	INC     B                               ; Register 7
	LD      A, $1F                          ; Text Color 1 / Text Color 0/Backdrop
	CALL    WriteRegister


    LD      A, (ControlPort)
    LD      C, A
	LD      A, $00                          ; Set low byte of VRAM address 0x00
	OUT     (C), A
	LD      A, $48                          ; Set high byte of VRAM address 0x08
	OUT     (C), A
	
	LD      HL, TMSFont                     ; Load address of font
	LD      B, $00
    LD      A, (DataPort)
	LD      C, A                            ; Write character glyphs to pattern table
	OTIR
	OTIR
	OTIR
	OTIR
	OTIR
	OTIR
	OTIR
	OTIR

ClearVRAM:
    PUSH    AF
    PUSH    BC
    PUSH    HL
    LD      HL, $1400                       ; Set the cursor to the beginning of the
    LD      (CursorPosition), HL            ; Pattern Name Table
    LD      A, $00                          ; Clear the LinePosition indicator
    LD      (LinePosition), A

    LD      A, (ControlPort)
    LD      C, A
    LD      A, $00                          ; Set low byte of VRAM address 0x00
    OUT     (C), A
    LD      A, $54                          ; Set high byte of VRAM address 0x14
    OUT     (C), A
    LD      A, (DataPort)
    LD      C, A
    XOR     A
    LD      B, $04
ClearVRAMLoop:
    PUSH    BC
    LD      B, $00
ClearVRAMLoopInner:
    OUT     (C), A
    DJNZ    ClearVRAMLoopInner
    POP     BC
    DJNZ    ClearVRAMLoop

    LD      HL, $1400                       ; Set the cursor to the beginning of the
    LD      (CursorPosition), HL            ; Pattern Name Table
    XOR     A                               ; Clear the LinePosition indicator
    LD      (LinePosition), A
    LD      A, (ControlPort)
    LD      C, A
    XOR     A                               ; Set low byte of VRAM address 0x00
    OUT     (C), A
    LD      A, $54                          ; Set high byte of VRAM address 0x14
    OUT     (C), A
        
    POP     HL
    POP     BC
    POP     AF
    RET

IRQHandler:
    PUSH    AF
    CALL    ReadStatus                      ; Read the status register (clears interrupt flag)
    LD      A, (CursorBlinkEnabled)         ; Check if blinking is enabled
    CP      0
    JP      Z, IRQExit                      ; If blinking is disabled, do nothing
    LD      A, (CursorBlinkTimer)           ; Load the cursor blink timer
    DEC     A                               ; Decrement
    JP      NZ, IRQExit                     ; Still have time left? Do nothing
    CALL    ToggleCursor                    ; Timer expired, toggle cursor visibility
IRQExit:
    POP     AF
    EI
	RETI

ToggleCursor:
    LD      A, (CursorVisible)
    CP      0
    JP      Z, SetCursorVisible
    JP      SetCursorHidden

; Draw the cursor character at the current cursor position
SetCursorVisible:
    PUSH    AF
    PUSH    DE
    LD      DE, (CursorPosition)
    CALL    ReadVRAM
    LD      (CursorCharBuffer), A
    LD      A, (CursorChar)
    CALL    WriteVRAM
    LD      A, 1
    LD      (CursorVisible), A
    LD      A, CursorBlinkTime
    LD      (CursorBlinkTimer), A           ; Reset the blink timer
    POP     DE
    POP     AF
    RET

; Draw the screen character at the current cursor position
SetCursorHidden:
    PUSH    AF
    PUSH    DE
    LD      DE, (CursorPosition)            ; Gets the current cursor position
    LD      A, (CursorCharBuffer)           ; Loads the buffered character from memory
    CALL    WriteVRAM                       ; Replace the cursor char on screen
    LD      A, 0                    
    LD      (CursorVisible), A              ; Un-set the cursor-visible flag
    LD      A, CursorBlinkTime
    LD      (CursorBlinkTimer), A           ; Reset the blink timer
    POP     DE
    POP     AF
    RET

LookForCard:
    LD      A, $80                          ; Start looking at base address 0x80
LookForCardLoop:
    LD      (DataPort), A                   ; Store base address as data port
    INC     A
    LD      (ControlPort), A                ; Store base address + 1 as control port

    PUSH    AF
    CALL    CheckCardExists                 ; Writes and reads back some VRAM to validate the card
    JP      Z, FoundCard
    POP     AF

    CP      $E1
    RET     NC
    ADD     A, $1F
    JP      LookForCardLoop

FoundCard:
    LD      A, $01
    LD      (Installed), A
    POP     AF
    RET


CheckCardExists:
    LD      DE, $1400
    LD      A, $00
    CALL    WriteVRAM
    CALL    ReadVRAM
    CP      $00
    RET     NZ                              ; Values don't match, so bail

    LD      DE, $1400
    LD      A, $55
    CALL    WriteVRAM
    CALL    ReadVRAM
    CP      $55
    RET     NZ                              ; Values don't match, so bail

    LD      DE, $1400
    LD      A, $AA
    CALL    WriteVRAM
    CALL    ReadVRAM
    CP      $AA
    RET     NZ                              ; Values don't match, so bail

    LD      DE, $1400
    LD      A, $FF
    CALL    WriteVRAM
    CALL    ReadVRAM
    CP      $FF
    RET

; Writes A to the VRAM location DE
WriteVRAM:
    PUSH    BC
    PUSH    AF
    LD      A, (ControlPort)
    LD      C, A
	LD      A, E
	OUT     (C), A
	LD      A, D
	AND     00111111b
	OR      01000000b
	OUT     (C), A
    LD      A, (DataPort)
    LD      C, A
	POP     AF
	OUT     (C), A
    POP     BC
    RET

; Writes data from memory addresses HL to HL + B starting at VRAM address DE
WriteVRAMBlock:
    PUSH    AF
    PUSH    BC
    LD      A, (ControlPort)
    LD      C, A
	LD      A, E
	OUT     (C), A
	LD      A, D
	AND     00111111b
	OR      01000000b
	OUT     (C), A
	LD      A, (DataPort)
    LD      C, A
	OTIR
    POP     BC
    POP     AF
    RET

; Reads the VDP status register into A
ReadStatus:
    LD      A, (ControlPort)
    LD      C, A
    IN      A, (C)
    RET

; Reads A from the VRAM location DE
ReadVRAM:
    PUSH    BC
    LD      A, (ControlPort)
    LD      C, A
	LD      A, E
	OUT     (C), A
	LD      A, D
	AND     00111111b
	OUT     (C), A
    LD      A, (DataPort)
    LD      C, A
	IN      A, (C)
    POP     BC
    RET

; Reads data into memory addresses HL to HL + B starting at VRAM address DE
ReadVRAMBlock:
    PUSH    AF
    PUSH    BC
    LD      A, (ControlPort)
    LD      C, A
    LD      A, E
    OUT     (C), A
    LD      A, D
    AND     00111111b
    OUT     (C), A
    LD      A, (DataPort)
    LD      C, A
    INIR
    POP     BC
    POP     AF
    RET

; Writes the data in A to VDP register number B
WriteRegister:
    PUSH    AF
    LD      A, (ControlPort)
    LD      C, A
    POP     AF
    OUT     (C), A
    LD      A, B
    AND     00000111b
    OR      10000000b
    OUT     (C), A
    RET

; Writes the byte in A at the cursor position
PutChar:
    PUSH    DE
    LD      DE, (CursorPosition)
    CALL    WriteVRAM
    POP     DE
    RET

; Prints the byte in A as an ASCII character at the cursor position and advances the cursor
PrintChar:
    CP      ASCII.FF                        ; Handle Form Feed (clear screen)
    JP      Z, ClearVRAM
    CP      ASCII.CR                        ; Handle carriage return
    JP      Z, LineFeed
    CP      ASCII.LF                        ; Handle line feed (does nothing, handled by CR)
    RET     Z
    CP      ASCII.BACKSPACE
    JP      Z, Backspace
    PUSH    BC
    PUSH    DE
    CALL    SetCursorHidden                 ; Hide the cursor so we don't lose on-screen characters
    LD      DE, (CursorPosition)            ; Load the cursor's current position
    CALL    WriteVRAM                       ; Write our character
    INC     DE                              ; Increment the cursor position
    LD      (CursorPosition), DE            ; Save cursor position
    CALL    IncrementLinePosition           ; Increment the position on the current line
    CALL    SetCursorVisible                ; Re-enable the cursor
    POP     DE
    POP     BC
    RET

; Handles a newline (combined CR LF, just inserts blanks for the rest of the current line)
LineFeed:
    PUSH    AF
    PUSH    BC
LineFeedLoop:
    LD      A, " "
    CALL    PrintChar
    LD      A, (LinePosition)
    CP      0
    JR      NZ, LineFeedLoop
    POP     BC
    POP     AF
    RET

; FUTURE USE: Handle a carriage return character (return the cursor to the beginning of the line)
PrintCR:
    PUSH    AF
    PUSH    DE
    CALL    SetCursorHidden
    LD      DE, (CursorPosition)
    LD      A, (LinePosition)
PrintCRLoop:
    CP      0
    JP      PrintCRDone
    DEC     DE
    DEC     A
    JP      PrintCRLoop
PrintCRDone:
    LD      (CursorPosition), DE
    LD      (LinePosition), A
    CALL    SetCursorVisible
    POP     DE
    POP     AF
    RET

; FUTURE USE: Handle a line-feed character (advance the cursor by 40 positions, check screen scroll)
PrintLF:
    PUSH    BC
    PUSH    DE
    CALL    SetCursorHidden
    LD      DE, (CursorPosition)
    LD      B, 40
PrintLFLoop:
    INC     DE
    DJNZ    PrintCRLoop
    LD      (CursorPosition), DE
    CALL    CheckScreenScroll
    CALL    SetCursorVisible
    POP     DE
    POP     BC
    RET

; Handles the backspace character
Backspace:
    PUSH    AF
    PUSH    DE
    PUSH    HL

    CALL    SetCursorHidden                 ; Hide the cursor
    LD      DE, (CursorPosition)            ; Get the current cursor position
    DEC     DE                              ; Go back a char
    LD      A, " "
    CALL    WriteVRAM
    LD      (CursorPosition), DE
    CALL    DecrementLinePosition
    CALL    SetCursorVisible
    POP     HL
    POP     DE
    POP     AF
    RET

IncrementLinePosition:
    PUSH    AF
    LD      A, (LinePosition)
    INC     A
    CP      40
    JR      NC, ResetLinePosition
    LD      (LinePosition), A
    POP     AF
    RET
ResetLinePosition:
    XOR     A
    LD      (LinePosition), A
    CALL    CheckScreenScroll
    POP     AF
    RET

DecrementLinePosition:
    PUSH    AF
    LD      A, (LinePosition)
    CP      0
    JR      Z, DecrementLinePositionReset
    DEC     A
    LD      (LinePosition), A
    POP     AF
    RET
DecrementLinePositionReset:
    LD      A, 40
    LD      (LinePosition), A
    POP     AF
    RET

CheckScreenScroll:
    PUSH    DE
    PUSH    HL
    
    LD      HL, (CursorPosition)
    LD      DE, TextScreenEnd
    OR      A                               ; CP HL, DE
    SBC     HL, DE                          ; CP HL, DE
    ADD     HL, DE                          ; CP HL, DE
    POP     HL
    POP     DE
    RET     C                               ; Not at the end of the screen, nothing to do

    PUSH    AF
    PUSH    DE
    PUSH    HL

    LD      HL, LineCopyBuffer          
    LD      DE, $1428                       ; Start at the second line
    LD      B, 240
    CALL    ReadVRAMBlock                   ; read 6 lines
    LD      HL, LineCopyBuffer
    LD      DE, $1400                       ; Go back to the first line
    LD      B, 240
    CALL    WriteVRAMBlock                  ; write 6 lines
    
    LD      HL, LineCopyBuffer          
    LD      DE, $1518                   
    LD      B, 240
    CALL    ReadVRAMBlock
    LD      HL, LineCopyBuffer
    LD      DE, $14F0
    LD      B, 240
    CALL    WriteVRAMBlock
    
    LD      HL, LineCopyBuffer          
    LD      DE, $1608                   
    LD      B, 240
    CALL    ReadVRAMBlock
    LD      HL, LineCopyBuffer
    LD      DE, $15E0
    LD      B, 240
    CALL    WriteVRAMBlock
    
    LD      HL, LineCopyBuffer          
    LD      DE, $16F8                   
    LD      B, 240
    CALL    ReadVRAMBlock
    LD      HL, LineCopyBuffer
    LD      DE, $16D0
    LD      B, 240
    CALL    WriteVRAMBlock

    LD      HL, $1798
    LD      (CursorPosition), HL
    
    POP     HL
    POP     DE
    POP     AF
    RET

; ------------------------------------------------------------------------------
	ENDP
; ------------------------------------------------------------------------------
